# -*- coding: utf-8 -*-
"""Voyager_Extension.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19W9uCLLzhpt29CFw8evmzpsWSrYLZtHj
"""

import torch
import torch.nn as nn
import torch.optim as optim
import numpy as np
import plotly.graph_objects as go
from sklearn.decomposition import PCA

# ------------------------------
# Helper: Simple model + dataset
# ------------------------------
def get_toy_data(n=1000):
    X = torch.randn(n, 2)
    y = (X[:, 0] * X[:, 1] > 0).float().unsqueeze(1)
    return X, y

class TinyNet(nn.Module):
    def __init__(self):
        super().__init__()
        self.net = nn.Sequential(
            nn.Linear(2, 16),
            nn.ReLU(),
            nn.Linear(16, 1),
            nn.Sigmoid()
        )

    def forward(self, x):
        return self.net(x)

# ------------------------------
# Helper: Train + Capture States
# ------------------------------
def capture_trajectory(optimizer_name, steps_per_snapshot=30, max_steps=300):
    X, y = get_toy_data()
    model = TinyNet()
    criterion = nn.BCELoss()

    if optimizer_name == "sgd":
        opt = optim.SGD(model.parameters(), lr=0.1)
    elif optimizer_name == "adam":
        opt = optim.Adam(model.parameters(), lr=0.01)
    elif optimizer_name == "rmsprop":
        opt = optim.RMSprop(model.parameters(), lr=0.01)
    else:
        raise ValueError(f"Unknown optimizer: {optimizer_name}")

    trajectory = []
    losses = []

    for step in range(max_steps):
        opt.zero_grad()
        out = model(X)
        loss = criterion(out, y)
        loss.backward()
        opt.step()
        losses.append(loss.item())

        if step % steps_per_snapshot == 0:
            weights = torch.cat([p.data.flatten() for p in model.parameters()]).detach().cpu().numpy()
            trajectory.append(weights)

    trajectory = np.array(trajectory)
    return trajectory, np.array(losses)

# ------------------------------
# PCA + Visualization
# ------------------------------
def pca_project(trajectories):
    all_points = np.concatenate(trajectories, axis=0)
    pca = PCA(n_components=3)
    pca.fit(all_points)
    return [pca.transform(t) for t in trajectories]

def visualize_trajectories(transformed, optim_names, losses):
    fig = go.Figure()

    for i, name in enumerate(optim_names):
        traj = transformed[i]
        fig.add_trace(go.Scatter3d(
            x=traj[:, 0], y=traj[:, 1], z=traj[:, 2],
            mode="lines+markers",
            marker=dict(size=4, color=np.linspace(0, 1, len(traj)), colorscale="Viridis"),
            name=name.upper()
        ))

    fig.update_layout(
        scene=dict(
            xaxis_title="PCA1",
            yaxis_title="PCA2",
            zaxis_title="PCA3",
        ),
        title="Optimizer Trajectory Comparison",
        template="plotly_dark",
        margin=dict(l=0, r=0, t=50, b=0)
    )
    return fig

# ------------------------------
# Metrics
# ------------------------------
def compute_metrics(trajectory, losses):
    diffs = np.diff(trajectory, axis=0)
    step_norms = np.linalg.norm(diffs, axis=1)
    path_length = np.sum(step_norms)
    curvature = np.mean(np.linalg.norm(np.diff(diffs, axis=0), axis=1))
    return {
        "path_length": path_length,
        "avg_step_norm": np.mean(step_norms),
        "curvature": curvature,
        "final_loss": losses[-1],
    }

# ------------------------------
# Master Function for Streamlit
# ------------------------------
def compare_and_visualize(optimizers, steps_per_snapshot=30, max_steps=300):
    trajectories, losses, metrics = [], [], {}

    for opt_name in optimizers:
        traj, loss_vals = capture_trajectory(opt_name, steps_per_snapshot, max_steps)
        trajectories.append(traj)
        losses.append(loss_vals)
        metrics[opt_name] = compute_metrics(traj, loss_vals)

    transformed = pca_project(trajectories)
    fig = visualize_trajectories(transformed, optimizers, losses)

    return {"fig": fig, "metrics": metrics}